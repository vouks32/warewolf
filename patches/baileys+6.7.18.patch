diff --git a/node_modules/baileys/WAProto/index.d.ts b/node_modules/baileys/WAProto/index.d.ts
index 519f533..6daae9c 100644
--- a/node_modules/baileys/WAProto/index.d.ts
+++ b/node_modules/baileys/WAProto/index.d.ts
@@ -36143,6 +36143,9 @@ export namespace proto {
 
         /** MessageKey participant */
         participant?: (string|null);
+
+        /** MessageKey participant */
+        number?: (string|null);
     }
 
     /** Represents a MessageKey. */
diff --git a/node_modules/baileys/lib/Socket/messages-recv.js b/node_modules/baileys/lib/Socket/messages-recv.js
index c31c73e..d87b0c5 100644
--- a/node_modules/baileys/lib/Socket/messages-recv.js
+++ b/node_modules/baileys/lib/Socket/messages-recv.js
@@ -69,14 +69,14 @@ const makeMessagesRecvSocket = (config) => {
                 to: callFrom,
             },
             content: [{
-                    tag: 'reject',
-                    attrs: {
-                        'call-id': callId,
-                        'call-creator': callFrom,
-                        count: '0',
-                    },
-                    content: undefined,
-                }],
+                tag: 'reject',
+                attrs: {
+                    'call-id': callId,
+                    'call-creator': callFrom,
+                    count: '0',
+                },
+                content: undefined,
+            }],
         });
         await query(stanza);
     };
@@ -186,14 +186,14 @@ const makeMessagesRecvSocket = (config) => {
                 msg.messageStubParameters = [metadata.subject];
                 msg.key = { participant: metadata.owner };
                 ev.emit('chats.upsert', [{
-                        id: metadata.id,
-                        name: metadata.subject,
-                        conversationTimestamp: metadata.creation,
-                    }]);
+                    id: metadata.id,
+                    name: metadata.subject,
+                    conversationTimestamp: metadata.creation,
+                }]);
                 ev.emit('groups.upsert', [{
-                        ...metadata,
-                        author: participant
-                    }]);
+                    ...metadata,
+                    author: participant
+                }]);
                 break;
             case 'ephemeral':
             case 'not_ephemeral':
@@ -322,9 +322,9 @@ const makeMessagesRecvSocket = (config) => {
                 const setPicture = (0, WABinary_1.getBinaryNodeChild)(node, 'set');
                 const delPicture = (0, WABinary_1.getBinaryNodeChild)(node, 'delete');
                 ev.emit('contacts.update', [{
-                        id: (0, WABinary_1.jidNormalizedUser)((_a = node === null || node === void 0 ? void 0 : node.attrs) === null || _a === void 0 ? void 0 : _a.from) || ((_c = (_b = (setPicture || delPicture)) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.hash) || '',
-                        imgUrl: setPicture ? 'changed' : 'removed'
-                    }]);
+                    id: (0, WABinary_1.jidNormalizedUser)((_a = node === null || node === void 0 ? void 0 : node.attrs) === null || _a === void 0 ? void 0 : _a.from) || ((_c = (_b = (setPicture || delPicture)) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.hash) || '',
+                    imgUrl: setPicture ? 'changed' : 'removed'
+                }]);
                 if ((0, WABinary_1.isJidGroup)(from)) {
                     const node = setPicture || delPicture;
                     result.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_ICON;
@@ -513,9 +513,9 @@ const makeMessagesRecvSocket = (config) => {
                     const status = (0, Utils_1.getStatusFromReceiptType)(attrs.type);
                     if (typeof status !== 'undefined' &&
                         (
-                        // basically, we only want to know when a message from us has been delivered to/read by the other person
-                        // or another device of ours has read some messages
-                        status >= WAProto_1.proto.WebMessageInfo.Status.SERVER_ACK ||
+                            // basically, we only want to know when a message from us has been delivered to/read by the other person
+                            // or another device of ours has read some messages
+                            status >= WAProto_1.proto.WebMessageInfo.Status.SERVER_ACK ||
                             !isNodeFromMe)) {
                         if ((0, WABinary_1.isJidGroup)(remoteJid) || (0, WABinary_1.isJidStatusBroadcast)(remoteJid)) {
                             if (attrs.participant) {
@@ -687,6 +687,9 @@ const makeMessagesRecvSocket = (config) => {
                     }
                     (0, Utils_1.cleanMessage)(msg, authState.creds.me.id);
                     await sendMessageAck(node);
+                    if (node?.attrs?.participant_pn) {
+                        msg.key.number = node.attrs.participant_pn
+                    }
                     await upsertMessage(msg, node.attrs.offline ? 'append' : 'notify');
                 })
             ]);
@@ -731,8 +734,8 @@ const makeMessagesRecvSocket = (config) => {
         }
         const pdoMessage = {
             placeholderMessageResendRequest: [{
-                    messageKey
-                }],
+                messageKey
+            }],
             peerDataOperationRequestType: WAProto_1.proto.Message.PeerDataOperationRequestType.PLACEHOLDER_MESSAGE_RESEND
         };
         setTimeout(() => {
